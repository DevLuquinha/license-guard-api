# License Management Systems â€“ Concepts

Author: Lucas Emmanuel Rodrigues Firmino de Paula
Date: 19/01/2026
Summary: This document describes essential software license management concepts to support architectural decisions for the LicenseGuard API.

### Guiding Question: 
"Why does LicenseGuard use online validation, license keys, and device-based licensing, and why does it NOT use advanced fingerprinting or offline licensing?"

### Purpose of the Document
This document focuses on conceptual understanding and architectural reasoning. It does not define implementation details or technical solutions.

### Study checklist:
[ ] What is a license management system?  
- Why licensing is not absolute security?<br>
`Because the licensing is just one security layer of the application. A hacker doesn't need to guess the encryption or find a valid key, he only need to find a specific part of the application and change the instruction so it always returns "yes or true".`

[ ] Common Licensing Types
- Simple License Key<br>
    `The software contains a mathematical algorithm that determines if a key is valid without check on server. Works 100% offline but it's so easy to leak.`
- Online validation (license server)<br>
    `The software 'calls home' to server and the server validate the 'key'. It's good because the server has absolute control, but requires an internet connection.`
- Node-locked (specific machine)<br>
    `The license is "locked" to the hardware of the computer (MAC Address or CPU ID), the license key will only work if the hardware ID matches. Prevents one license from being used on multiple computers, but frustrating for users when they need use on another machine or upgrade the hardware.`
- Device-based (by identifier)<br>
    `Similar to node-locked, but the user "register" a device, the users might allow to have "multiple active devices".`
- Floating licenses (just concept)<br>
    `The user can buy 10 'seats' but install the plugin on 100 computers. Only 10 people can use it at the same time.`
- Offline vs online validation<br>
    `The offline is most used when the application don't use internet any time.`

[ ] I should be able to answer: "Why LicenseGuard MVP uses online validation + device-based?"<br>
`Because has the absolute control and the users can register multiple 'devices'`

[ ] Devices identifiers (concepts)
- What is typically used as "device id"?<br>
`For desktop software, It's usually a "sum" of hardware strings, like "Motherboard Serial Number" + "CPU ID" + "MAC Address"`
- pros and cons of:
    - GUID generated by the application<br>
    `It's easiest to implement, but is Zero persinstence also a user can copy that GUID to 100 other computers to clone the license.`
    - Simple hash<br>
    `Get 2 or 3 hardware strings, concatenate them, and run them through an algorithm like SHA-256. Have privacy-friendly, don't store the user's actual hardware names on server but if the user upgrades their hard drive, the hash changes completely.`
    - Advanced fingerprint (why it not use now)<br>
    `This involves collecting dozens of data points: installed fonts, screen resolution, GPU drivers, audio sample rates, and even keyboard latency patterns. Why it not use: Instability: These attributes change too often, Probabilistic vs. Deterministic: Fingerprinting gives you a "95% chance it's the same device." For licensing, you need 100% certainty, or you'll get angry support tickets from paying customers.`
    - Why the backend should not fully trust the client<br>
    `Because a hacker can simply change some things on client side.`

Note: For the LicenseGuard MVP, the device identifier is treated as an opaque string provided by the client. The backend does not interpret or validate how this identifier is generated.

[ ] Expiration and Revocation
- Difference between:
    - Auto Expiration<br>
    `The trigger is clock-based, the predictability is high, both the user and server know exactly when it ends. Ex: "Monthly/Annual subscriptions, free trials."`
    - Manual Revocation<br>
    `The trigger is action-based, triggered by an admin or system event, the predictability is lower because it can happen at any moment. Ex: "Fraud detection, payment chargebacks"`
- Why revocation is domain rule, not just a technical detail<br>
`Revocation carries "meaning", it represents a break in the contract between a software and the customer. Revoking a license often triggers other business processes like "send a email for user".Revocation is the "kill switch" used for legal compliance.`

- What happens when:
    - License expires<br>
    `The user enters Grace Mode (limited use) or Locked Mode (no use). No changes are usually made to the database record until the user refresh license again.`
    - License revoked<br>
    `Real-time Kill, the license it obsolete and the deviceId or email is added a 'blacklist' to they cannot activate any new keys on that hardware.`
    - Device changes<br>
    `Have some alternatives: `<br>
    `1. Block: Tell the user "Maximum devices reached"`<br>
    `2. Auto-Migrate: Allow the change but "Revoke" the old device ID automatically"`<br>
    `3. Manual Reset: Force the user to visit the 'dashboard' to "Deactivate" the old machine."`<br>

Note: Concepts like grace period, blacklisting, dashboards, and email notifications are outside the LicenseGuard MVP scope and are mentioned here for conceptual completeness only.Note: Concepts like grace period, blacklisting, dashboards, and email notifications are outside the LicenseGuard MVP scope and are mentioned here for conceptual completeness only.

[ ] License Validation (Logic Flow)
- Input:
    - License key
    - Device id
- Decision:
    - Exists?
    - Is active?
    - Is expired?
    - Is revoked?
    - Authorized device?
- Output:
    - Valid or Not Valid
    - Reason

`In a production system, you want to fail as early as possible (the "fail-fast" principle) to save database resources and provide immediate feedback to the user.`

```
1. Exists? Query Database for the license Key. If the record is null, stop.
2. Is revoked? Check the 'is_revoked' boolean field (Check early for security).
3. Is active?  Check if the license status is ACTIVE (not revoked or expired).
4. Is expired? Compare current_date with the expiration_date in the database.
5. Device authorized? Compared the provided 'device_id' against the one(s) stored for that key.

The output needs to return a structured response, like to:
{
  "isValid": false,
  "reasonCode": "DEVICE_MISMATCH",
  "message": "This license is already in use on another computer.",
  "metadata": {
    "maxDevices": 1,
    "supportUrl": "https://my-web-sitecom/help"
  }
}

Database Cost: Checking if a key "exists" is a primary key lookup. Checking complex device-matching logic or usage history is "heavier," so it happens last.